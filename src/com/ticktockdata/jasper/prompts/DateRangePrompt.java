package com.ticktockdata.jasper.prompts;

import classicacctapp.AutoComplete;
import com.ticktockdata.jasper.DateRange;
import com.ticktockdata.jasper.JasperReportImpl;
import java.util.*;
import net.sf.jasperreports.engine.JRExpression;
import net.sf.jasperreports.engine.JRParameter;
import net.sf.jasperreports.engine.JRPropertiesHolder;
import net.sf.jasperreports.engine.JRPropertiesMap;
import net.sf.jasperreports.engine.type.ParameterEvaluationTimeEnum;

/**
 * This class was heavily refactored 2022-10-06:07. <br>Removed the previous
 * DateRange class and placed the DateRange enum (formerly RangeName) into a
 * separate file, and split the date functions into their own class,
 * {@link com.ticktockdata.jasper.DateService}.  JAM
 *
 * @author JAM
 * @see DateRange
 * @see com.ticktockdata.jasper.DateService#setDateRangeAllImpl(com.ticktockdata.jasper.DateRangeALL) 
 */
public class DateRangePrompt extends PromptComponent<List<Date>> implements JRParameter {

    private String startDateParameterName;
    private String endDateParameterName;

    private boolean triggerCustom = true;
    private boolean suppressTrigger = false;

    /**
     * Creates new form DateRangePrompt
     */
    public DateRangePrompt() {
        initComponents();
        
        for (DateRange rn : DateRange.values()) {
            cboRange.addItem(rn);
        }
        logger.debug("Created a new DateRangePrompt");
        AutoComplete.enable(cboRange);
        
        if (getDescription() == null || getDescription().trim().isEmpty()) {
            // this parameter has a pre-defined description
            super.setDescription("Select Date Range");
        } else {
            this.setDescription(getDescription());
        }
        
        cboRange.setSelectedItem(DateRange.THIS_MONTH);
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblDescription = new javax.swing.JLabel();
        cboRange = new javax.swing.JComboBox();
        dateStart = new classicacctapp.ClassicAccDatePicker();
        lblTo = new javax.swing.JLabel();
        dateEnd = new classicacctapp.ClassicAccDatePicker();

        setBorder(javax.swing.BorderFactory.createEtchedBorder());

        lblDescription.setText("Select Date Range");

        cboRange.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                cboRangeItemStateChanged(evt);
            }
        });

        dateStart.setFont(dateStart.getFont().deriveFont(dateStart.getFont().getSize()-1f));
        dateStart.setFormats("MM/dd/yy");
        dateStart.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                dateStartPropertyChange(evt);
            }
        });

        lblTo.setText("To");

        dateEnd.setFont(dateEnd.getFont().deriveFont(dateEnd.getFont().getSize()-1f));
        dateEnd.setFormats("MM/dd/yy");
        dateEnd.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                dateEndPropertyChange(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblDescription, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(dateStart, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(3, 3, 3)
                        .addComponent(lblTo)
                        .addGap(3, 3, 3)
                        .addComponent(dateEnd, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(cboRange, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(6, 6, 6))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addComponent(lblDescription)
                .addGap(3, 3, 3)
                .addComponent(cboRange, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(9, 9, 9)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(dateStart, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblTo)
                    .addComponent(dateEnd, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(6, 6, 6))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void cboRangeItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_cboRangeItemStateChanged
        
        // this upates the dates
        if (!suppressTrigger && cboRange.getSelectedItem() instanceof DateRange) {
            setDateRange((DateRange) cboRange.getSelectedItem());
        }
        
    }//GEN-LAST:event_cboRangeItemStateChanged

    private void dateStartPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_dateStartPropertyChange

        if (!suppressTrigger && evt.getPropertyName().equalsIgnoreCase("date")) {
            setStartDate(dateStart.getDate());
        }

    }//GEN-LAST:event_dateStartPropertyChange

    private void dateEndPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_dateEndPropertyChange
        
        if (!suppressTrigger && evt.getPropertyName().equalsIgnoreCase("date")) {
            setEndDate(dateEnd.getDate());
        }

    }//GEN-LAST:event_dateEndPropertyChange

    @Override
    public void setPromptValue(List<Date> value) {
        if (value == null) {
            this.promptValue = new ArrayList<>();
        } else if (value.size() == 2) {
            this.promptValue = value;
            setStartDate(promptValue.get(0));
            setEndDate(promptValue.get(1));
        } else {
            throw new IllegalArgumentException("List of Dates must have 2 values, startDate and endDate.");
        }
    }

    /**
     * List of dates.
     *
     * @return always returns list of 2 dates,
     */
    @Override
    public List<Date> getPromptValue() {
        if (promptValue == null) {
            promptValue = new ArrayList<>();
        } else {
            promptValue.clear();
        }
        promptValue.add(dateStart.getDate());
        promptValue.add(dateEnd.getDate());
        return promptValue;
    }

    public void fillParameters(JasperReportImpl report) {
        report.setParameter(getStartDateParameterName(), getStartDate());
        report.setParameter(getEndDateParameterName(), getEndDate());
    }

    // the reason we created this - to implement start AND end dates!
    /**
     * @return the startDate
     */
    public Date getStartDate() {
        return dateStart.getDate();
    }

    /**
     * @param startDate the startDate to set
     */
    public void setStartDate(Date startDate) {
        Date newStartDate = startDate = startDate == null ? DateRange.TODAY.getStartDate() : startDate;
        if (!Objects.equals(dateStart.getDate(), newStartDate)) {
            this.dateStart.setDate(newStartDate);
        }
        if (triggerCustom && cboRange.getSelectedItem() != DateRange.CUSTOM) {
            cboRange.setSelectedItem(DateRange.CUSTOM);
        }
    }

    /**
     * @return the endDate
     */
    public Date getEndDate() {
        return dateEnd.getDate();
    }

    /**
     * @param endDate the endDate to set
     */
    public void setEndDate(Date endDate) {
        Date newEndDate = endDate == null ? DateRange.TODAY.getEndDate() : endDate;
        if (!Objects.equals(dateEnd.getDate(), newEndDate)) {
            this.dateEnd.setDate(newEndDate);
            if (triggerCustom) {
                cboRange.setSelectedItem(DateRange.CUSTOM);
            }
        }
        if (triggerCustom && cboRange.getSelectedItem() != DateRange.CUSTOM) {
            cboRange.setSelectedItem(DateRange.CUSTOM);
        }
    }

    public void setDateRange(DateRange dateRange) {

        if (suppressTrigger || dateRange == null) {
            return;
        }

        triggerCustom = false;  // disable set(Start/End)Date calling custom
        suppressTrigger = true;  // prevent looping when cboRange.setSelectedItem is called!
        
        if (dateRange != DateRange.CUSTOM) {
            setStartDate(dateRange.getStartDate());
            setEndDate(dateRange.getEndDate());
        }
        
        if (!dateRange.equals(cboRange.getSelectedItem())) {
            cboRange.setSelectedItem(dateRange);
        }

        triggerCustom = true;
        suppressTrigger = false;

    }

    /**
     * @return the startDateParameterName
     */
    public String getStartDateParameterName() {
        return startDateParameterName;
    }

    /**
     * @param startDateParameterName the startDateParameterName to set
     */
    public void setStartDateParameterName(String startDateParameterName) {
        this.startDateParameterName = startDateParameterName;
    }

    /**
     * @return the endDateParameterName
     */
    public String getEndDateParameterName() {
        return endDateParameterName;
    }

    /**
     * @param endDateParameterName the endDateParameterName to set
     */
    public void setEndDateParameterName(String endDateParameterName) {
        this.endDateParameterName = endDateParameterName;
    }
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox cboRange;
    private classicacctapp.ClassicAccDatePicker dateEnd;
    private classicacctapp.ClassicAccDatePicker dateStart;
    private javax.swing.JLabel lblDescription;
    private javax.swing.JLabel lblTo;
    // End of variables declaration//GEN-END:variables

    @Override
    public void refreshData() {
        // don't update - it resets the date which we don't want
        //setRangeName(DateRange.THIS_MONTH);
    }

    // the default methods of JRParameter - implemented those I thought we needed
    @Override
    public String getName() {
        return "P_DATE_RANGE";
    }


    @Override
    public void setDescription(String description) {
        if (lblDescription != null) {
            lblDescription.setText(description);
        }
        super.setDescription(description);
    }

    @Override
    public Class<?> getValueClass() {
        return java.util.Date.class;
    }

    @Override
    public String getValueClassName() {
        return java.util.Date.class.getName();
    }

    @Override
    public boolean isSystemDefined() {
        return false;
    }

    @Override
    public boolean isForPrompting() {
        return true;
    }

    @Override
    public ParameterEvaluationTimeEnum getEvaluationTime() {
        return ParameterEvaluationTimeEnum.EARLY;
    }

    @Override
    public JRExpression getDefaultValueExpression() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Class<?> getNestedType() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public String getNestedTypeName() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public boolean hasProperties() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public JRPropertiesMap getPropertiesMap() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public JRPropertiesHolder getParentProperties() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    /**
     * We don't hope clone gets called!
     *
     * @return
     */
    @Override
    public Object clone() {

        try {
            logger.warn(" %%% Nasty: clone() called on DateRange!");
            return super.clone();
        } catch (CloneNotSupportedException ex) {
            return null;
        }
    }

}
